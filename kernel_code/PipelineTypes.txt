//TODO - Implement
typedef struct
{
  float x, y, z, w;
} Quat;
typedef struct
{
  //TODO
  float x1,x2,x3;
  float y1,y2,y3;
  float z1,z2,z3;
} Mat3;

typedef struct 
{
  float3 pos;
  float x,y,z,w;
  
  //Mat3 invInertiaTensor;
  float x1,x2,x3;
  float y1,y2,y3;
  float z1,z2,z3;
  
  float mass;
  
  float3 linearVel;
  float3 angularVel;
  
  float linearDrag;
  float angularDrag;
  
  //AABB bv;
  float3 bvOrigMin;
  float3 bvOrigMax;
  float3 bvMin;
  float3 bvMax;
  //int bodyID;
  
  //TODO - Complex collider type instead of sphere
  float sphereRadius;
  
  float3 accumForce;
  float3 accumTorque;
  
} Body;

__kernel void Integrate(__global Body *bodies, float dt)
{
  int gid = get_global_id(0);
  
  //Linear Vel  
  //TODO - handle 0/infinite mass
  float mass = max(bodies[gid].mass, 0.5f);
  float3 linearAccel = bodies[gid].accumForce / mass;
  //Gravity
  linearAccel += (float3)(0.0f, -9.81f, 0.0f);
  bodies[gid].linearVel += linearAccel * (dt);
  
  //Angular - TODO
  //angularVel += invInertiaTensor * torque * dt

  //Simplified drag applications - estimation, not strictly accurate
  bodies[gid].linearVel *= (1.0f - (dt) * bodies[gid].linearDrag);
  bodies[gid].angularVel *= (1.0f - (dt) * bodies[gid].angularDrag);
  
  //Applying velocities to adjust position and orientation
  bodies[gid].pos += bodies[gid].linearVel * (dt); //TODO - if integration is done first, should update BV
  //TODO - adjust rotation by angular velocity, need to lookup some Quat stuff
  
  //Resetting accumulators
  bodies[gid].accumForce = (float3)(0.0f);
  bodies[gid].accumTorque = (float3)(0.0f);
  
  //DEBUG - used for testing struct packing / padding
  /*
  bodies[gid].pos = (float3)(-1.0f);
  bodies[gid].x = 1.0f;
  bodies[gid].y = 1.0f;
  bodies[gid].z = 1.0f;
  bodies[gid].w = 1.0f;
  bodies[gid].x1 = 2.0f;
  bodies[gid].x2 = 2.0f;
  bodies[gid].x3 = 2.0f;
  bodies[gid].y1 = 2.0f;
  bodies[gid].y2 = 2.0f;
  bodies[gid].y3 = 2.0f;
  bodies[gid].z1 = 2.0f;
  bodies[gid].z2 = 2.0f;
  bodies[gid].z3 = 2.0f;
  bodies[gid].mass = 3.0f;
  bodies[gid].linearVel = (float3)(4.0f);
  bodies[gid].angularVel = (float3)(5.0f);
  bodies[gid].bvOrigMin = (float3)(6.0f);
  bodies[gid].bvOrigMax = (float3)(7.0f);
  bodies[gid].bvMin = (float3)(8.0f);
  bodies[gid].bvMax = (float3)(9.0f);
  bodies[gid].accumForce = (float3)(10.0f);
  bodies[gid].accumTorque = (float3)(11.0f);
  */
}

typedef struct
{
  int leftIndx;
  int rightIndx;
} IDPair;

#define MAX_BODIES 2048

typedef struct
{
  float3 origMin;
  float3 origMax;
  
  float3 min;
  float3 max;
  
  int bodyID;
} AABB;

AABB GetBVFrom(Body b)
{
  AABB ret;
  ret.origMin = b.bvOrigMin;
  ret.origMax = b.bvOrigMax;
  ret.min = b.bvMin;
  ret.max = b.bvMax;
  return ret;
}

__kernel void BroadPhase(__global Body *bodies, int numBodies, __global IDPair *pairs, volatile __global int *lastPairIndx, volatile __global int *pairsFound)
{
  int gid = get_global_id(0);
  
  AABB thisBV = GetBVFrom(bodies[gid]);

  int numFound = 0;
  
  for(int i = gid + 1; i < numBodies; i++)
  {
    AABB againstBV = GetBVFrom(bodies[i]);
  
    bool xResult = thisBV.max.x >= againstBV.min.x || thisBV.min.x <= againstBV.max.x;
    bool yResult = thisBV.max.y >= againstBV.min.y || thisBV.min.y <= againstBV.max.y;
    bool zResult = thisBV.max.z >= againstBV.min.z || thisBV.min.z <= againstBV.max.z;
    
    bool testResult = xResult & yResult & zResult;
    
    if(testResult)
    {
      IDPair newPair;
      newPair.leftIndx = gid;
      newPair.rightIndx = i;
      
      int indx = atomic_inc(lastPairIndx);
      pairs[indx] = newPair;
      
      numFound++;
    }
  }

  //Adding number found to total - for easy workload assignment for narrowphase
  atomic_add(pairsFound, numFound);
}

bool SphereSphere(Body l, Body r)
{
  float radSum = l.sphereRadius + r.sphereRadius;
  float dist = distance(l.pos, r.pos);
  return dist < radSum;
}

__kernel void NarrowPhase(__global IDPair *pairs, __global Body *bodies)
{
  int gid = get_global_id(0);
  
  Body leftBody = bodies[pairs[gid].leftIndx];
  Body rightBody = bodies[pairs[gid].rightIndx];
  
  //Assuming spheres for simplest collision atm
  
  //
  float radSum = leftBody.sphereRadius + rightBody.sphereRadius;
  float dist = distance(leftBody.pos, rightBody.pos);
  
  if(distance < radSum)
  {
    
  }
  
  //TODO
  //Find what type of colliders each body has
  //then send to correct function
}

__kernel void ConstraintSolver()
{
  
}